### 1. 프로젝트 목표 (Objectives)
이론으로 배운 다음 3가지의 내용을 직접 구현한다

1. "대부분의 객체는 금방 죽는다"는 가설을 전제로, 힙을 두 영역(Young/Old)으로 나누는 것
2. GC가 실행될 때 객체의 메모리 주소가 바뀜(Copy/Compact). 이때 이 객체를 가리키고 있던 다른 객체들의 포인터를 깨지지 않고 갱신하는 것 구현
3. `malloc`을 쓰지 않고 포인터 덧셈만으로 메모리를 할당하는 Bump Pointer Allocation 구현

---

### 2. 작업 범위
JVM의 일부인 메모리 관리자 부분 구현. 불필요한 복잡도를 줄이기 위해 다음과 같은 제약을 두겠음.

* C 사용 (Standard C99 이상 권장)
* 단일 스레드를 실행 환경으로 설정 (동기화/Lock 불필요)
* 진짜 자바 바이트코드를 읽지 않음.
* 대신 C 함수로 가상 머신의 동작을 흉내 냄.

* ##### 객체 구조
* 모든 객체는 고정된 크기 혹은 단순한 형태(예: `INT` 필드와 `REFERENCE` 필드만 가짐)로 가정함.
* 순환 참조를 만들 수 있음.


* ##### Java Serial GC 알고리즘
* Young Generation: Semi-space 방식 (메모리를 반으로 나눠 살아있는 것만 복사).
* Old Generation: Mark-Compact (살아있는 객체를 한쪽으로 밈).
* Young에서 일정 횟수(Age) 이상 살아남으면 Old로 승격.

---

### 3. 완료 기준

다음 시나리오를 통과하는 `main.c` 테스트 코드가 정상 동작하면 완료로 간주.

1. 객체를 계속 생성해도 터지지 않고 Minor GC가 돌며 공간을 확보한다.
2. 살아있는 객체(루트에서 도달 가능)는 GC 후에도 데이터가 깨지지 않고 유지된다.
3. 오래 살아남은 객체가 Old 영역으로 이동하는 로그가 확인된다.
4. Old 영역에 있는 객체가 Young 영역 객체를 가리키고 있을 때, Minor GC가 이를 놓치지 않고 마킹한다(Write Barrier 동작 확인).
5. 도달 불가능한 객체는 GC 후 힙 사용량 집계에서 사라져야 한다.

---